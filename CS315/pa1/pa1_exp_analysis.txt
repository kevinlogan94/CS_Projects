EXTERNAL DOCUMENTATION
CS315001 Spring 2015
Project 1 Milestone 3
Name: Kevin Logan
Date: 2/1/15
A) PROBLEM SPECIFICATION:
a) formal problem description: Your task is to design an efficient algorithm for the smooth sequences problem, 
to implement your solution, to test it, to tabulate time and the number of comparisons, and to describe the results.

b) intuitive problem description: Your goal for this program is to program an algorithm that gives you the 
lowest possible D-smooth of a sequence. This sequence can be a sequence you make up youself or one that is
given to you by the instructor to test if the algorithm works in all possible cases. 
	The program must also count the number of comparisons that you make to see if each integer tested
is the correct D. It must be used to tabulate the time and then after your done with it you must describe
the results.  

B) SOLUTION
	The program takes your input and finds the highest number in the sequence that you enter. It then 
makes a sequence from 0 to the sum of all the numbers that you inputted. It takes
the middle number of the new sequence and checks if that is a valid D. 
	This algorithm focuses on using binary search to determine the lowest possible D. If the D is valid
it reduces the length of the list and tests the middle number in that sequence, otherwise it does the same 
thing for the upper half of the list. The program will keep repeating this process till there is 1 number 
left to pick and thats the lowest possible D-smooth.  

C) TESTING
Purpose:
- testing for correctness: prepare "difficult inputs" that test
all potential cases and boundary conditions.
- testing for measuring the number of comparisons between elements of
  the input sequence. The focus is on the worst case analysis.
Types of input sequences: (only marked with X are needed for pa1)
-  small examples for  basic testing
- (X) instructorâ€™s sample inputs
- synthesized input (generated by script or by hand) - this input may
also include "random" inputs. Note that using "random" inputs do not
necessarily translate into the average run time analysis.
- application-domain inputs: inputs that come from the domain
of real applications of the solution.
- (X) inputs prepared for the run-time performance analysis.
- (X) fun inputs: the binary representation of your SID.
Regarding the last item, we are interested in the worst-case analysis.  To
prepare suitable data one needs to undertand what is "difficult" for the
algorithm and its implementation.  In our case, we want to force the algorithm
to make many binary search queries, each requiring many calls (or executions)
of the decision procedure.
In our case, we can consider the following inputs of size n =  2^k - 1,
1 < k < 11.
inputs of the form: 1, 1, 1, 1, 1, 1, 1
inputs of the form: 7, 6, 5, 4, 3, 2, 1
For each sequence of the above form for k = 2, .., 10
tabulate:
(1) n					   seq 1: 7	seq 2:7
(2) minimal d					  3	      6
(3) M (the right end for the binary search)	  7	      28
(4) #comparisons				  19	      37
(5) exact value of n*log_2 M			  19.65	      33.65
(6) ratio: (4)/(5)				  .9669	      1.09955
For the inputs in the first form, M=n=2^k-1 and the ceiling of log_2M is $k$. Here it is assumed that your program takes M to be equal to the sum of the input elements. (Compute M and log_2 M for the other form.) It is critical to provide accurate results from running your program on test data and to clearly describe the process so it can be independently reproduced by others.
Analyze the results: As you can see the larger the integers the higher your comparisons, M, minimal d, and
	value of nlog2M is going to be. My ratio was close to the number 1 for both examples. For all my test cases in the 
script.txt file every single one worked with the correct minimal D. The experiment agrees with the theoretical run time
bounds because the binary search in the interval 1..M is used to select d for testing and the running time of testing d 
is linear.  

ADDITIONAL NOTES:
Very efficient algorithm
